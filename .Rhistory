lppGA <- data.frame(
csType = factor(c(rep(1,dim(lppAv4GA)[2]), rep(2,dim(lppAv4GA)[2]), rep(3,dim(lppAv4GA)[2])), labels = csLabels),
time = rep(seq(startSeg,startSeg+(dim(lppAv4GA)[2]-1)*1000/sRate,1000/sRate),3),
LPP = c(colMeans(lppAv4GA),
colMeans(lppNeu4GA),
colMeans(lppMin4GA)),
row.names = NULL)
lppGAima <- data.frame(
csType = factor(c(rep(1,dim(lppAv4GAima)[2]), rep(2,dim(lppAv4GAima)[2]), rep(3,dim(lppAv4GAima)[2])), labels = csLabels),
time = rep(seq(startSeg,startSeg+(dim(lppAv4GAima)[2]-1)*1000/sRate,1000/sRate),3),
LPP = c(colMeans(lppAv4GAima),
colMeans(lppNeu4GAima),
colMeans(lppMin4GAima)),
row.names = NULL)
lppGAreal <- data.frame(
csType = factor(c(rep(1,dim(lppAv4GAreal)[2]), rep(2,dim(lppAv4GAreal)[2]), rep(3,dim(lppAv4GAreal)[2])), labels = csLabels),
time = rep(seq(startSeg,startSeg+(dim(lppAv4GAreal)[2]-1)*1000/sRate,1000/sRate),3),
LPP = c(colMeans(lppAv4GAreal),
colMeans(lppNeu4GAreal),
colMeans(lppMin4GAreal)),
row.names = NULL)
dataLPPWithin <- dataLPP[,c("partInd","usGroup","Av_allTr","Neu_allTr","Min_allTr")]
# remove each participant's average from each single value
dataLPPWithin[,3:5] <- as.matrix(dataLPPWithin[,3:5]) -
rowMeans(as.matrix(dataLPPWithin[,3:5]))
# prepare data frame for bar plot with means from standard dataset and SE from
# dataset without between-subject variance
meanLPP <- data.frame(
usGroup = factor(c(rep(1,3),rep(2,3)),
labels = c("Imagery-Based","Classical")),
CS = factor(c(1,2,3,1,2,3),
labels = c("CS+\nav","CS+\nneu","CS-\n")),
mean = c(describe(dataLPP[dataLPP$usGroup == "ima", c(4,5,6)])$mean,
describe(dataLPP[dataLPP$usGroup == "real", c(4,5,6)])$mean),
se = c(describe(dataLPPWithin[dataLPPWithin$usGroup == "ima", 3:5])$se,
describe(dataLPPWithin[dataLPPWithin$usGroup == "real", 3:5])$se)
)
lineSize = 1
yMin = -5
yMax = 12
plotFS <- 9
showSig <- TRUE
# ERP at PZ for imagery-based conditioning group
graphLPPima <- ggplot(data = lppGAima, aes(x = time, y = LPP, colour = csType)) +
theme_classic() +
geom_rect(xmin = TWOI[1], xmax = TWOI[2], ymin = yMin, ymax = yMax, fill = "gray90", colour = NA) +
geom_line(aes(colour = csType), linewidth = lineSize) +
scale_x_continuous(breaks = seq(-200,1000,200)) +
scale_colour_discrete(type = scico(n = 3, palette = "davos", begin = .1, end = .7)) +
lims(y = c(yMin, yMax)) +
labs(title = "Imagery-Based Conditioning", x = "Time (ms)", y = expression(paste("ERP amplitude at Pz ", (µV))), fill = "", colour = "") +
guides(colour = guide_legend(order = 1), fill = FALSE) +
theme(
legend.position = "none",
plot.title = element_blank(),
axis.title.x = element_text(margin = margin(t = 5), size = plotFS, color = "black"),
axis.text.x = element_text(margin = margin(t = 5), size = plotFS, color = "black"),
axis.title.y = element_text(margin = margin(r = 5), size = plotFS, color = "black"),
axis.text.y = element_text(margin = margin(r = 5), size = plotFS, color = "black"))
# ERP at PZ for classical conditioning group
graphLPPreal <- ggplot(data = lppGAreal, aes(x = time, y = LPP, colour = csType)) +
theme_classic() +
geom_rect(xmin = TWOI[1], xmax = TWOI[2], ymin = yMin, ymax = yMax, fill = "gray90", colour = NA) +
geom_line(aes(colour = csType), linewidth = lineSize) +
scale_x_continuous(breaks = seq(-200,1000,200)) +
scale_colour_discrete(type = scico(n = 3, palette = "davos", begin = .1, end = .7)) +
lims(y = c(yMin, yMax)) +
labs(title = "Classical Conditioning", x = "Time (ms)", y = expression(paste("ERP amplitude at Pz ", (µV))), fill = "", colour = "") +
guides(colour = guide_legend(order = 1), fill = FALSE) +
theme(
legend.position = "none",
plot.title = element_blank(),
axis.title.x = element_text(margin = margin(t = 5), size = plotFS, color = "black"),
axis.text.x = element_text(margin = margin(t = 5), size = plotFS, color = "black"),
axis.title.y = element_text(margin = margin(r = 5), size = plotFS, color = "black"),
axis.text.y = element_text(margin = margin(r = 5), size = plotFS, color = "black"))
# bar plot for imagery-based conditioning group
graphLPPmeansIma <- ggplot(data = meanLPP[meanLPP$usGroup == "Imagery-Based",], aes(x = CS, y = mean, fill = CS)) +
theme_classic() +
geom_col(aes(fill = CS), position = position_dodge(width = .9)) +
scale_fill_discrete(type = scico(n = 3, palette = "davos", begin = .1, end = .7)) +
geom_errorbar(aes(ymin = mean-se, ymax = mean+se, width = .1), position = position_dodge(width = .9)) +
scale_x_discrete(name = " ", labels = csLabels, position = "bottom") +
scale_y_continuous(name = "Mean LPP amplitude (300-700 ms)", limits = c(0,14), breaks = c(0,5,10), expand = c(0,0)) +
coord_cartesian(ylim = c(0,12), clip = 'off') +
theme(legend.position = "none",
plot.title = element_text(size = plotFS, color = "black", face = "bold", hjust = .5),
axis.text.x = element_text(margin = margin(t = 5), size = plotFS, color = "black"),
axis.ticks.x = element_blank(),
axis.title.y = element_text(margin = margin(r = 5), size = plotFS),
axis.text.y = element_text(margin = margin(r = 5), size = plotFS, color = "black"),
axis.ticks.y = element_line(colour = "black"));
# bar plot for classical conditioning group
graphLPPmeansReal <- ggplot(data = meanLPP[meanLPP$usGroup == "Classical",], aes(x = CS, y = mean, fill = CS)) +
theme_classic() +
geom_col(aes(fill = CS), position = position_dodge(width = .9)) +
scale_fill_discrete(type = scico(n = 3, palette = "davos", begin = .1, end = .7)) +
geom_errorbar(aes(ymin = mean-se, ymax = mean+se, width = .1), position = position_dodge(width = .9)) +
scale_x_discrete(name = " ", labels = csLabels, position = "bottom") +
scale_y_continuous(name = "Mean LPP amplitude (300-700 ms)", limits = c(0,14), breaks = c(0,5,10), expand = c(0,0)) +
coord_cartesian(ylim = c(0,12), clip = 'off') +
theme(legend.position = "none",
plot.title = element_blank(),
axis.text.x = element_text(margin = margin(t = 5), size = plotFS, color = "black"),
axis.ticks.x = element_blank(),
axis.title.y = element_text(margin = margin(r = 5), size = plotFS),
axis.text.y = element_text(margin = margin(r = 5), size = plotFS, color = "black"),
axis.ticks.y = element_line(colour = "black"));
if (showSig == TRUE){
graphLPPmeansIma <- graphLPPmeansIma +
geom_segment(aes(x = 1, y = mean+se+.5, xend = 2, yend = mean+se+.5), data = meanLPP[1,]) +
geom_text(aes(label = "†", x = 1.5, y = mean+se+1), size = plotFS/4, data = meanLPP[1,], family = "Helvetica") +
geom_segment(aes(x = 1, y = mean+se+1.5, xend = 3, yend = mean+se+1.5), data = meanLPP[1,]) +
geom_text(aes(label = "***", x = 2, y = mean+se+1.6), size = plotFS/2, data = meanLPP[1,])
graphLPPmeansReal <- graphLPPmeansReal +
geom_segment(aes(x = 1, y = mean+se+.5, xend = 2, yend = mean+se+.5), data = meanLPP[4,]) +
geom_text(aes(label = "**", x = 1.5, y = mean+se+.6), size = plotFS/2, data = meanLPP[4,]) +
geom_segment(aes(x = 1, y = mean+se+1.5, xend = 3, yend = mean+se+1.5), data = meanLPP[4,]) +
geom_text(aes(label = "†", x = 2, y = mean+se+2), size = plotFS/4, data = meanLPP[4,], family = "Helvetica")
}
# Average individual amplitudes across whole sample
topoAvgAV <- colMeans(topoMatAV)
topoAvgNEU <- colMeans(topoMatNEU)
topoAvgMIN <- colMeans(topoMatMIN)
topoAvgAVima <- colMeans(topoMatAV[importRatings$group == "ima",])
topoAvgNEUima <- colMeans(topoMatNEU[importRatings$group == "ima",])
topoAvgMINima <- colMeans(topoMatMIN[importRatings$group == "ima",])
topoAvgAVreal <- colMeans(topoMatAV[importRatings$group == "real",])
topoAvgNEUreal <- colMeans(topoMatNEU[importRatings$group == "real",])
topoAvgMINreal <- colMeans(topoMatMIN[importRatings$group == "real",])
# number of electrodes
nrChans = length(topoAvgAV)
# Create data frame with factors lab, driving frequency & modulation function,
# electrode name, x & y coordinates for plot & LPP amplitude
# across groups
dfTopos <- data.frame(
electrode = chanLocs$name,
x = chanLocs$x,
y = chanLocs$y,
csp_av = topoAvgAV,
csp_neu = topoAvgNEU,
csm = topoAvgMIN
)
# imagery-based conditioning group
dfToposIma <- data.frame(
electrode = chanLocs$name,
x = chanLocs$x,
y = chanLocs$y,
csp_av = topoAvgAVima,
csp_neu = topoAvgNEUima,
csm = topoAvgMINima
)
# classical conditioning group
dfToposReal <- data.frame(
electrode = chanLocs$name,
x = chanLocs$x,
y = chanLocs$y,
csp_av = topoAvgAVreal,
csp_neu = topoAvgNEUreal,
csm = topoAvgMINreal
)
# compute difference values comparing CS+av to the mean of CS+neu and CS-
dfTopos$contrast <- 1*dfTopos$csp_av - 0.5*dfTopos$csp_neu - 0.5*dfTopos$csm
dfToposIma$contrast <- 1*dfToposIma$csp_av - 0.5*dfToposIma$csp_neu - 0.5*dfToposIma$csm
dfToposReal$contrast <- 1*dfToposReal$csp_av - 0.5*dfToposReal$csp_neu - 0.5*dfToposReal$csm
# settings for topography plots
topoRes <- 400
chanCol <- "black"
nrColors <- 8
minLim <- min(dfTopos$contrast)
maxLim <- max(dfTopos$contrast)
absLim <- max(abs(c(minLim, maxLim)))
### create topography plots
# across groups
topoAll <- topoplot(data = dfTopos,
contour = FALSE, interp_limit = "head", highlights = chanNames,
grid_res = topoRes, quantity = "contrast", scaling = .5)
# transform color scale into discrete steps
topoAll$data$fill <- as.numeric(bin(data = topoAll$data$fill, nbins = nrColors))
# imagery-based conditioning group
topoIma <- topoplot(data = dfToposIma,
contour = FALSE, interp_limit = "head", highlights = chanNames,
grid_res = topoRes, quantity = "contrast", scaling = .33,
limits = c(-absLim, absLim)) +
labs(title = expression(paste("CS+"[av], " vs [CS+"[neu], " & CS-]"))) +
theme(legend.position = "bottom",
legend.text = element_text(size = plotFS),
plot.title = element_text(hjust = 0.5, size = plotFS))
# format the color bar
topoIma$guides$fill$barwidth <- unit(6, "lines")
topoIma$guides$fill$barheight <- unit(.5, "lines")
topoIma$guides$fill$title <- expression(paste(Delta, " amplitude ", (µV)))
topoIma$guides$fill$title.theme$size <- plotFS
topoIma$guides$fill$title.theme$angle <- 0
topoIma$guides$fill$title.position <- "bottom"
topoIma$guides$fill$title.hjust <- 0.5
topoIma$guides$fill$nbin <- nrColors
# imagery-based conditioning group
topoReal <- topoplot(data = dfToposReal,
contour = FALSE, interp_limit = "head", highlights = chanNames,
grid_res = topoRes, quantity = "contrast", scaling = .33,
limits = c(-absLim, absLim)) +
labs(title = expression(paste("CS+"[av], " vs [CS+"[neu], " & CS-]"))) +
theme(legend.position = "bottom",
legend.text = element_text(size = plotFS),
plot.title = element_text(hjust = 0.5, size = plotFS))
# format the color bar
topoReal$guides$fill$barwidth <- unit(6, "lines")
topoReal$guides$fill$barheight <- unit(.5, "lines")
topoReal$guides$fill$title <- expression(paste(Delta, " amplitude ", (µV)))
topoReal$guides$fill$title.theme$size <- plotFS
topoReal$guides$fill$title.theme$angle <- 0
topoReal$guides$fill$title.position <- "bottom"
topoReal$guides$fill$title.hjust <- 0.5
topoReal$guides$fill$nbin <- nrColors
# use the same, discrete color scales for the two groups
topoFillVec <- c(topoIma$data$fill, topoReal$data$fill)
totMin <- min(topoFillVec)
totMax <- max(topoFillVec)
topoFillVec <- as.numeric(bin(data = topoFillVec, nbins = nrColors))
topoFillVec <- (topoFillVec-1) / (nrColors-1)
topoFillVec <- topoFillVec*(totMax-totMin) + totMin
topoIma$data$fill <- topoFillVec[1 : (length(topoFillVec)/2)]
topoReal$data$fill <- topoFillVec[(length(topoFillVec)/2+1) : length(topoFillVec)]
### combining graphs into one figure
# add margins
graphLPPima <- graphLPPima + theme(plot.margin = unit(c(10,5,5,5), "mm"))
graphLPPreal <- graphLPPreal + theme(plot.margin = unit(c(10,5,5,5), "mm"))
graphLPPmeansIma <- graphLPPmeansIma + theme(plot.margin = unit(c(10,2.5,5,7.5), "mm"))
graphLPPmeansReal <- graphLPPmeansReal + theme(plot.margin = unit(c(10,2.5,5,7.5), "mm"))
topoIma <- topoIma + theme(plot.margin = unit(c(10,5,2.6,5), "mm"))
topoReal <- topoReal + theme(plot.margin = unit(c(10,5,2.6,5), "mm"))
# create panels and merge them
graphLPProw1 <- ggarrange(graphLPPima, graphLPPmeansIma, topoIma,
ncol = 3, nrow = 1,
widths = c(3,2,2))
graphLPProw2 <- ggarrange(graphLPPreal, graphLPPmeansReal, topoReal,
ncol = 3, nrow = 1,
widths = c(3,2,2))
graphLPP <- ggarrange(graphLPProw1,graphLPProw2,
ncol = 1, nrow = 2,
labels = c("A) Imagery-Based Conditioning", "B) Classical Conditioning"),
hjust = -.05
)
# plot
graphLPP
# saving it
ggsave(filename = paste0(pathname, "/supplement/04s_lpp_exploratory_timeCourseBarPlot.eps"),
plot = graphLPP,
width = 200,
height = 150,
units = "mm"
)
ggsave(filename = paste0(pathname, "/supplement/04s_lpp_exploratory_timeCourseBarPlot.pdf"),
plot = graphLPP,
width = 200,
height = 150,
units = "mm"
)
# --- author: Christian Panitz
# --- encoding: en_US.UTF-8
# --- R version: 4.0.3 (2020-10-10) -- "Bunny-Wunnies Freak Out"
# --- RStudio version: 1.3.1093
# --- script version: Jan 2023
# --- content: supplementary theta analyses - plot topographies
###################
### preparing R ###
###################
# random number generator seed (necessary for Bayesian ANOVAs)
# created with [set.seed(NULL)] and [sample(2^31 - 1, 1)]
rngSeed <- 814677222
# (installing and) loading required packages
# will install newest package version, not necessarily the version originally used!
if(!is.element("tidyr",installed.packages()[,1])) {install.packages("tidyr")}
library(tidyr) # ver. 1.1.2
if(!is.element("psych",installed.packages()[,1])) {install.packages("psych")}
library(psych) # ver. 2.0.9
if(!is.element("effectsize",installed.packages()[,1])) {install.packages("effectsize")}
library(effectsize) # ver. 2.0.9
if(!is.element("ez",installed.packages()[,1])) {install.packages("ez")}
library(ez) # ver. 4.4-0
if(!is.element("BayesFactor",installed.packages()[,1])) {install.packages("BayesFactor")}
library(BayesFactor) # ver. 2.0.9
if(!is.element("bayestestR",installed.packages()[,1])) {install.packages("BayesFactor")}
library(bayestestR) #
if(!is.element("ggplot2",installed.packages()[,1])) {install.packages("ggplot2")}
library(ggplot2) # ver. 3.3.2
if(!is.element("scico",installed.packages()[,1])) {install.packages("scico")}
library(scico) # ver. 1.2.0
if(!is.element("scales",installed.packages()[,1])) {install.packages("scales")}
library(scales) #
if(!is.element("ggpubr",installed.packages()[,1])) {install.packages("ggpubr")}
library(ggpubr) #
if(!is.element("flextable",installed.packages()[,1])) {install.packages("flextable")}
library(flextable) #
if(!is.element("stringr",installed.packages()[,1])) {install.packages("stringr")}
library(stringr) #
if(!is.element("here",installed.packages()[,1])) {install.packages("here")}
library(here) #
########################
### data preparation ###
########################
# load rating data from text file
# (see realCond3_allratings_readme.txt for more details)
pathname <- here()
importRatings <- read.csv(paste0(pathname, "/experimentData/imaCond3_demographicsAndRatings.txt"), sep=",")
# load Theta data from text file
# (see imaCond3_theta_readme.txt for more details)
importTheta <- read.csv(paste0(pathname, "/experimentData/imaCond3_theta.txt"), sep = ",")
importTheta <- merge(importRatings[,c("partCode","group")], importTheta, by = "partCode")
importTheta <- importTheta[order(importTheta$partCode),]
importThetaLong <- pivot_longer(importTheta, cols = Fp1_acqTotal_csplusav:O2_acq2_csminus,
names_to = c("channel", "time", "CS"), names_sep = "_", values_to = "theta")
# select all mean theta across all trials
importThetaLong <- importThetaLong[importThetaLong$time == "acqTotal", c("partCode","group","channel","CS","theta")]
topoAvgAVima <- aggregate(theta ~ channel, data = importThetaLong[importThetaLong$group == "ima" & importThetaLong$CS == "csplusav", ], FUN = "mean")
topoAvgNEUima <- aggregate(theta ~ channel, data = importThetaLong[importThetaLong$group == "ima" & importThetaLong$CS == "csplusneu", ], FUN = "mean")
topoAvgMINima <- aggregate(theta ~ channel, data = importThetaLong[importThetaLong$group == "ima" & importThetaLong$CS == "csminus", ], FUN = "mean")
topoAvgAVreal <- aggregate(theta ~ channel, data = importThetaLong[importThetaLong$group == "real" & importThetaLong$CS == "csplusav", ], FUN = "mean")
topoAvgNEUreal <- aggregate(theta ~ channel, data = importThetaLong[importThetaLong$group == "real" & importThetaLong$CS == "csplusneu", ], FUN = "mean")
topoAvgMINreal <- aggregate(theta ~ channel, data = importThetaLong[importThetaLong$group == "real" & importThetaLong$CS == "csminus", ], FUN = "mean")
# Load channel locations and transform from 3D theta + radius into 2D x & y
# for plotting purposes
loadname <- paste0(pathname,"/channelLocations/chanLocs_biosemi64.txt")
chanLocs <- read.csv(loadname, sep = ";")
chanLocs$thetaRadian <- pi/180*chanLocs$theta
chanLocs$x <- chanLocs$radius*sin(chanLocs$thetaRadian)*200
chanLocs$y <- chanLocs$radius*cos(chanLocs$thetaRadian)*200
names(chanLocs) <- gsub("name","electrode",names(chanLocs))
# number of electrodes
nrChans = length(topoAvgAVima)
# Create data frame with factors lab, driving frequency & modulation function,
# electrode name, x & y coordinates for plot & theta power for different conditions
dfTopos <- data.frame(
electrode = topoAvgAVima$channel,
ima_allCS = rowMeans(cbind(topoAvgAVima$theta, topoAvgNEUima$theta, topoAvgMINima$theta)),
ima_DiffAvNeu = topoAvgAVima$theta - topoAvgNEUima$theta,
ima_DiffAvMin = topoAvgAVima$theta - topoAvgMINima$theta,
real_allCS = rowMeans(cbind(topoAvgAVreal$theta, topoAvgNEUreal$theta, topoAvgMINreal$theta)),
real_DiffAvNeu = topoAvgAVreal$theta - topoAvgNEUreal$theta,
real_DiffAvMin = topoAvgAVreal$theta - topoAvgMINreal$theta
)
dfTopos <- merge(chanLocs, dfTopos, by = "electrode")
# settings for topography plots
topoRes <- 200
chanCol <- "black"
nrColors <- 8
minLimAll <- min(c(dfTopos$ima_allCS, dfTopos$real_allCS))
maxLimAll <- max(c(dfTopos$ima_allCS, dfTopos$real_allCS))
minLimDiff <- min(c(dfTopos$ima_DiffAvNeu, dfTopos$ima_DiffAvMin, dfTopos$real_DiffAvNeu, dfTopos$real_DiffAvMin))
maxLimDiff <- max(c(dfTopos$ima_DiffAvNeu, dfTopos$ima_DiffAvMin, dfTopos$real_DiffAvNeu, dfTopos$real_DiffAvMin))
absLimDiff <- max(abs(c(minLimDiff, maxLimDiff)))
### create topography plots
topoAllIma <- topoplot(data = dfTopos,
contour = FALSE, interp_limit = "head", highlights = "Fz",
grid_res = topoRes, quantity = "ima_allCS",
limits = c(-maxLimAll, maxLimAll), method = "gam")
# --- author: Christian Panitz
# --- encoding: en_US.UTF-8
# --- R version: 4.0.3 (2020-10-10) -- "Bunny-Wunnies Freak Out"
# --- RStudio version: 1.3.1093
# --- script version: Jan 2023
# --- content: supplementary theta analyses - plot topographies
###################
### preparing R ###
###################
# random number generator seed (necessary for Bayesian ANOVAs)
# created with [set.seed(NULL)] and [sample(2^31 - 1, 1)]
rngSeed <- 814677222
# (installing and) loading required packages
# will install newest package version, not necessarily the version originally used!
if(!is.element("tidyr",installed.packages()[,1])) {install.packages("tidyr")}
library(tidyr) # ver. 1.1.2
if(!is.element("psych",installed.packages()[,1])) {install.packages("psych")}
library(psych) # ver. 2.0.9
if(!is.element("effectsize",installed.packages()[,1])) {install.packages("effectsize")}
library(effectsize) # ver. 2.0.9
if(!is.element("ez",installed.packages()[,1])) {install.packages("ez")}
library(ez) # ver. 4.4-0
if(!is.element("BayesFactor",installed.packages()[,1])) {install.packages("BayesFactor")}
library(BayesFactor) # ver. 2.0.9
if(!is.element("bayestestR",installed.packages()[,1])) {install.packages("BayesFactor")}
library(bayestestR) #
if(!is.element("ggplot2",installed.packages()[,1])) {install.packages("ggplot2")}
library(ggplot2) # ver. 3.3.2
if(!is.element("scico",installed.packages()[,1])) {install.packages("scico")}
library(scico) # ver. 1.2.0
if(!is.element("scales",installed.packages()[,1])) {install.packages("scales")}
library(scales) #
if(!is.element("ggpubr",installed.packages()[,1])) {install.packages("ggpubr")}
library(ggpubr) #
if(!is.element("flextable",installed.packages()[,1])) {install.packages("flextable")}
library(flextable) #
if(!is.element("stringr",installed.packages()[,1])) {install.packages("stringr")}
library(stringr) #
if(!is.element("here",installed.packages()[,1])) {install.packages("here")}
library(here) #
library(eegUtils)
########################
### data preparation ###
########################
# load rating data from text file
# (see realCond3_allratings_readme.txt for more details)
pathname <- here()
importRatings <- read.csv(paste0(pathname, "/experimentData/imaCond3_demographicsAndRatings.txt"), sep=",")
# load Theta data from text file
# (see imaCond3_theta_readme.txt for more details)
importTheta <- read.csv(paste0(pathname, "/experimentData/imaCond3_theta.txt"), sep = ",")
importTheta <- merge(importRatings[,c("partCode","group")], importTheta, by = "partCode")
importTheta <- importTheta[order(importTheta$partCode),]
importThetaLong <- pivot_longer(importTheta, cols = Fp1_acqTotal_csplusav:O2_acq2_csminus,
names_to = c("channel", "time", "CS"), names_sep = "_", values_to = "theta")
# select all mean theta across all trials
importThetaLong <- importThetaLong[importThetaLong$time == "acqTotal", c("partCode","group","channel","CS","theta")]
topoAvgAVima <- aggregate(theta ~ channel, data = importThetaLong[importThetaLong$group == "ima" & importThetaLong$CS == "csplusav", ], FUN = "mean")
topoAvgNEUima <- aggregate(theta ~ channel, data = importThetaLong[importThetaLong$group == "ima" & importThetaLong$CS == "csplusneu", ], FUN = "mean")
topoAvgMINima <- aggregate(theta ~ channel, data = importThetaLong[importThetaLong$group == "ima" & importThetaLong$CS == "csminus", ], FUN = "mean")
topoAvgAVreal <- aggregate(theta ~ channel, data = importThetaLong[importThetaLong$group == "real" & importThetaLong$CS == "csplusav", ], FUN = "mean")
topoAvgNEUreal <- aggregate(theta ~ channel, data = importThetaLong[importThetaLong$group == "real" & importThetaLong$CS == "csplusneu", ], FUN = "mean")
topoAvgMINreal <- aggregate(theta ~ channel, data = importThetaLong[importThetaLong$group == "real" & importThetaLong$CS == "csminus", ], FUN = "mean")
# Load channel locations and transform from 3D theta + radius into 2D x & y
# for plotting purposes
loadname <- paste0(pathname,"/channelLocations/chanLocs_biosemi64.txt")
chanLocs <- read.csv(loadname, sep = ";")
chanLocs$thetaRadian <- pi/180*chanLocs$theta
chanLocs$x <- chanLocs$radius*sin(chanLocs$thetaRadian)*200
chanLocs$y <- chanLocs$radius*cos(chanLocs$thetaRadian)*200
names(chanLocs) <- gsub("name","electrode",names(chanLocs))
# number of electrodes
nrChans = length(topoAvgAVima)
# Create data frame with factors lab, driving frequency & modulation function,
# electrode name, x & y coordinates for plot & theta power for different conditions
dfTopos <- data.frame(
electrode = topoAvgAVima$channel,
ima_allCS = rowMeans(cbind(topoAvgAVima$theta, topoAvgNEUima$theta, topoAvgMINima$theta)),
ima_DiffAvNeu = topoAvgAVima$theta - topoAvgNEUima$theta,
ima_DiffAvMin = topoAvgAVima$theta - topoAvgMINima$theta,
real_allCS = rowMeans(cbind(topoAvgAVreal$theta, topoAvgNEUreal$theta, topoAvgMINreal$theta)),
real_DiffAvNeu = topoAvgAVreal$theta - topoAvgNEUreal$theta,
real_DiffAvMin = topoAvgAVreal$theta - topoAvgMINreal$theta
)
dfTopos <- merge(chanLocs, dfTopos, by = "electrode")
# settings for topography plots
topoRes <- 200
chanCol <- "black"
nrColors <- 8
minLimAll <- min(c(dfTopos$ima_allCS, dfTopos$real_allCS))
maxLimAll <- max(c(dfTopos$ima_allCS, dfTopos$real_allCS))
minLimDiff <- min(c(dfTopos$ima_DiffAvNeu, dfTopos$ima_DiffAvMin, dfTopos$real_DiffAvNeu, dfTopos$real_DiffAvMin))
maxLimDiff <- max(c(dfTopos$ima_DiffAvNeu, dfTopos$ima_DiffAvMin, dfTopos$real_DiffAvNeu, dfTopos$real_DiffAvMin))
absLimDiff <- max(abs(c(minLimDiff, maxLimDiff)))
### create topography plots
topoAllIma <- topoplot(data = dfTopos,
contour = FALSE, interp_limit = "head", highlights = "Fz",
grid_res = topoRes, quantity = "ima_allCS",
limits = c(-maxLimAll, maxLimAll), method = "gam")
topoAllIma$guides$fill$title <- "Power Density (µV^2/Hz)"
topoAllIma$guides$fill$barheight <- unit(9, "lines")
topoAllReal <- topoplot(data = dfTopos,
contour = FALSE, interp_limit = "head", highlights = "Fz",
grid_res = topoRes, quantity = "real_allCS",
limits = c(-maxLimAll, maxLimAll), method = "gam")
topoAllReal$guides$fill$title <- "Power Density (µV^2/Hz)"
topoAllReal$guides$fill$barheight <- unit(9, "lines")
topoAllImaAvNeu <- topoplot(data = dfTopos,
contour = FALSE, interp_limit = "head", highlights = "Fz",
grid_res = topoRes, quantity = "ima_DiffAvNeu",
limits = c(-absLimDiff, absLimDiff), method = "gam")
topoAllImaAvNeu$guides$fill$title <- "Diff. in Power Density (µV^2/Hz)"
topoAllImaAvNeu$guides$fill$barheight <- unit(12, "lines")
topoAllImaAvMin <- topoplot(data = dfTopos,
contour = FALSE, interp_limit = "head", highlights = "Fz",
grid_res = topoRes, quantity = "ima_DiffAvMin",
limits = c(-absLimDiff, absLimDiff), method = "gam")
topoAllImaAvMin$guides$fill$title <- "Diff. in Power Density (µV^2/Hz)"
topoAllImaAvMin$guides$fill$barheight <- unit(12, "lines")
topoAllRealAvNeu <- topoplot(data = dfTopos,
contour = FALSE, interp_limit = "head", highlights = "Fz",
grid_res = topoRes, quantity = "real_DiffAvNeu",
limits = c(-absLimDiff, absLimDiff), method = "gam")
topoAllRealAvNeu$guides$fill$title <- "Diff. in Power Density (µV^2/Hz)"
topoAllRealAvNeu$guides$fill$barheight <- unit(12, "lines")
topoAllRealAvMin <- topoplot(data = dfTopos,
contour = FALSE, interp_limit = "head", highlights = "Fz",
grid_res = topoRes, quantity = "real_DiffAvMin",
limits = c(-absLimDiff, absLimDiff), method = "gam")
topoAllRealAvMin$guides$fill$title <- "Diff. in Power Density (µV^2/Hz)"
topoAllRealAvMin$guides$fill$barheight <- unit(12, "lines")
# add margins
topoAllIma <- topoAllIma + theme(plot.margin = unit(c(5,5,5,5), "mm"))
topoAllReal <- topoAllReal + theme(plot.margin = unit(c(5,5,5,5), "mm"))
topoAllImaAvNeu <- topoAllImaAvNeu + theme(plot.margin = unit(c(5,5,5,5), "mm"))
topoAllImaAvMin <- topoAllImaAvMin + theme(plot.margin = unit(c(5,5,5,5), "mm"))
topoAllRealAvNeu <- topoAllRealAvNeu + theme(plot.margin = unit(c(5,5,5,5), "mm"))
topoAllRealAvMin <- topoAllRealAvMin + theme(plot.margin = unit(c(5,5,5,5), "mm"))
allTopos <- ggarrange(topoAllIma, topoAllImaAvNeu, topoAllImaAvMin,
topoAllReal, topoAllRealAvNeu, topoAllRealAvMin,
labels = c("Imagery-based: Average across all CS",
"   Imagery-based: CS+av vs CS+neu   ",
"    Imagery-based: CS+av vs CS-     ",
"  Classical: Average across all CS  ",
"     Classical: CS+av vs CS+neu     ",
"      Classical: CS+av vs CS-       "),
hjust = -0.2, nrow = 2, ncol = 3)
allTopos
# save it
ggsave(filename = paste0(pathname, "/supplement/05s_theta_topographies.pdf"),
plot = allTopos,
width = 400,
height = 200,
units = "mm"
)
